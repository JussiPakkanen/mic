#!/bin/bash

# gp_setup
# This is part of the Mer git-packaging suite
# It sets up a git repo to use git-pkg

# If not
# Check if a mer-pkg exists already
# Create mer-pkg
# Add templates

pkg_branch=pkg-mer

[[ -d .git ]] || {
    echo "This is not a git repository; use gp_setup when you've cloned or created a normal src repo that is ready for packaging".
    exit 1
}

usage() {
    cat <<EOF
    gp_setup --start | --end | -- pkg 
    gp_setup --existing [--pristine] <tag> <packaging dir> <patch-tag>
    gp_setup --pristine
 
       Used to setup an existing git repo for git-pkg

    --existing
       Take an existing set of packaging and apply to an upstream git
       <tag> should be the tag/sha1 of the original git to use for the tarball
       <packaging dir> is the source of the spec/yaml/changes/patches
       <patch-tag> is the id which will be used for the branch+tag for the patches
       
    --pristine
       Take an existing set of packaging and make a pristine-tar tree
       
    --start
       Creates a pkg-mer branch with a suitable .gitignore and a _src file

    --end
       Adds and all files and runs a commit; then returns to the original branch.

EOF
}
count_commits() {
    git rev-list $1..$2 | wc -l
}

use_existing() {
    gp_type="git"
    if [[ $1 == "--pristine" ]]; then
	shift
	gp_type="pristine-tar"
    fi
    mkdir -p .gp
    tag=$1
    patchdir=$2
    pbranch=$3
    echo tag=$tag >> .gp/env
    echo patchdir=$patchdir >> .gp/env
    echo pbranch=$pbranch >> .gp/env

    echo .gp/ > .git/info/exclude

    numspec=$(ls $patchdir/*spec 2>/dev/null | wc -l)
    numyaml=$(ls $patchdir/*yaml 2>/dev/null | wc -l)
    if [[ $numspec -gt 1 ]] || [[ $numyaml -gt 1 ]]; then
	echo "gp_setup doesn't support packaging with >1 .spec or .yaml file"
	exit 1
    fi

    specfile=$(cd $patchdir; ls *.spec 2>/dev/null)
    yamlfile=$(cd $patchdir; ls *.yaml 2>/dev/null)

    # Guess the tarball
    tarball=$(cd $patchdir; find * -name *t*gz)
    [[ ! $tarball ]] && tarball=$(cd $patchdir; find * -name *t*bz2)

    git checkout -f $tag
    git checkout -b $pbranch
    if [[ $gp_type == "pristine-tar" ]] ; then
	echo "Pristine tar : removing all files and unpacking tarball to record any delta to $tag"
	pristine-tar commit $patchdir/$tarball $tag
	rm -rf *
	tar xf $patchdir/$tarball
	dir=$(ls)
	echo "Found $dir"
	mv $dir/* $dir/.* . 2>/dev/null
	echo remove $dir
	rmdir $dir
	echo done remove
	git add .; git ls-files --deleted | xargs --no-run-if-empty git rm
	git commit --allow-empty -m"pristine-tar-delta: Import any changes from the released tarball into the Mer source tree ready for local patches"
    fi
    for patch in $(cd $patchdir; grep Patch.*: *spec | cut -f2 -d:); do
	echo Applying $patch
	patch --fuzz=2 -p1 --no-backup-if-mismatch -s < $patchdir/$patch
	git commit -am"$(basename $patch .patch)"
    done

    
    if [[ $gp_type == "pristine-tar" ]] ; then
	echo Found this many commits:
	count_commits $tag $pbranch
	tag1="${pbranch}~$(($(count_commits $tag $pbranch ) - 1))"
    else
	tag1=$tag
    fi

    git format-patch --find-renames --binary -N --no-numbered $tag1..$pbranch > .gp/patches

    echo "Making PatchXX source entries and %patchXX entries for .spec file in .gp/spec-Patch and .gp/spec-patch"
    count=1
    > .gp/spec-Patch
    while read patch; do
        echo "Patch$((count++)): $patch" >> .gp/spec-Patch
    done< .gp/patches

    count=1
    > .gp/spec-patch
    while read patch; do
        echo "%patch$((count++)) -p1"  >> .gp/spec-patch
    done< .gp/patches

    echo "Making Patches; entries for Spectacle .yaml file for .spec file in .gp/spec-yaml"
    echo "Patches:" > .gp/spec-yaml
    while read patch; do
        echo " - $patch" >> .gp/spec-yaml
    done < .gp/patches

    echo $gp_type:$tarball:$tag:$pbranch > .gp/_src
    
    prepare

    cp $patchdir/* .
    rm $tarball
    rm *patch

    if [[ -e $yamlfile ]]; then
	cat .gp/spec-yaml >> $yamlfile
	echo Please edit/move the Patches section at the end of $yamlfile and then exit this subshell
	bash
    else
	if [[ $gp_type == "pristine-tar" ]] ; then
	    /mer/mer/gitpkg/update_spec_patches < $specfile > .gp/$specfile
	else
	    /mer/mer/gitpkg/update_spec_patches --setup_src < $specfile > .gp/$specfile
	fi
	mv .gp/$specfile $specfile
    fi

    git add * >/dev/null 2>&1

    git commit -m"Initial git package of $tag as $pbranch"

    echo Guessed 
    cat _src
    echo for _src

    echo "gp_setup --existing isn't thoroughly tested - please fix and/or report any bugs you find"
}

prepare() {
    if git show-ref --verify --quiet refs/heads/${pkg_branch}; then
	echo "${pkg_branch} branch exists already"
	exit 1
    fi

    # get the symbolic name
    current_branch=$(git symbolic-ref -q HEAD)
    current_branch=${current_branch##refs/heads/}
    # If not set, use the sha1
    current_branch=${current_branch:-$(git log -1 --format="%H")}
    
    # Store state
    mkdir -p .gp
    echo current_branch=${current_branch} >> .gp/env

    # FIXME - should check if a stash is needed
    DO_STASH=1

    [[ $DO_STASH ]] && git stash save
    git checkout --orphan ${pkg_branch}
    git rm -q -rf . 
    echo .osc > .gitignore
    if [[ -e .gp/_src ]]; then
	cp .gp/_src _src
    else
	touch _src
    fi
    git add _src .gitignore
}

pkg() {
    # Guess the version
    tag1=$(head -1 *.changes | cut -f2 -d\> | cut -f2 -d-)
    tag1=${ver## }

    # Guess the tarball
    tarball=$(cd $patchdir; find * -name *t*gz)
    [[ ! $tarball ]] && tarball=$(cd $patchdir; find * -name *t*bz2)
    echo git:$tarball:$ver > _src

    git add *changes *spec *yaml >/dev/null 2>&1
    git rm --cached $tgz $tbz >/dev/null 2>&1

    echo Guessed 
    cat _src
    echo for _src
    echo Please check tags and see if any local patches need importing to git.
    echo When done run
    echo gp_setup --end
    
}



finalise() {
    git commit -m"Packaging commit with empty _src"
    git checkout $current_branch

    [[ $DO_STASH ]] && git stash pop

    echo "${pkg_branch} created with an empty _src file."
}

[ -e .gb/env ] && . .gb/env

case $1 in
    --existing )
	shift
	use_existing $* ;;

    --start )
	prepare ;;

    --pkg )
	pkg ;;

    --end )
	finalise ;;

    * )
	usage ;;
esac


